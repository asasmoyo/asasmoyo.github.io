<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>relax, you're probably doing fine</title><link>https://asasmoyo.github.io/</link><description>Recent content on relax, you're probably doing fine</description><generator>Hugo - gohugo.io</generator><language>en</language><contact>arba.sasmoyo@gmail.com</contact><copyright/><atom:link href="https://asasmoyo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>No `for_each` Item in Array in Terraform</title><link>https://asasmoyo.github.io/no-for-each-item-in-array-in-terraform/</link><pubDate>Sat, 28 Mar 2020 17:15:23 +0700</pubDate><author>Arba Sasmoyo</author><guid>https://asasmoyo.github.io/no-for-each-item-in-array-in-terraform/</guid><description/><content>&lt;p>I was importing my team&amp;rsquo;s PagerDuty setup into Terraform today. There are 6 people in PagerDuty users so I thought, I would create locals block with users as array of map containing each name and email. Then I&amp;rsquo;d feed &lt;code>local.users&lt;/code> into &lt;code>pagerduty_user&lt;/code> resource using &lt;code>for_each&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-hcl" data-lang="hcl">&lt;span style="color:#66d9ef">locals&lt;/span> {
users &lt;span style="color:#f92672">=&lt;/span> [
{
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;John Doe&amp;#34;&lt;/span>
email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;john@company.com&amp;#34;&lt;/span>
},
{
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Somebody&amp;#34;&lt;/span>
email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;somebody@company.com&amp;#34;&lt;/span>
},
&lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> ...
]
}
&lt;span style="color:#66d9ef">resource&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pagerduty_user&amp;#34; &amp;#34;users&amp;#34;&lt;/span> {
for_each &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">local&lt;/span>.&lt;span style="color:#66d9ef">users&lt;/span>
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">each&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.&lt;span style="color:#66d9ef">name&lt;/span>
email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">each&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.&lt;span style="color:#66d9ef">email&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>It turned out, &lt;code>for_each&lt;/code> doesn&amp;rsquo;t accept array, it only accepts map or set. So above code didn&amp;rsquo;t work but it has to be like bellow:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-hcl" data-lang="hcl">&lt;span style="color:#66d9ef">locals&lt;/span> {
users &lt;span style="color:#f92672">=&lt;/span> [
john &lt;span style="color:#f92672">=&lt;/span> {
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;John Doe&amp;#34;&lt;/span>
email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;john@company.com&amp;#34;&lt;/span>
},
somebody &lt;span style="color:#f92672">=&lt;/span> {
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Somebody&amp;#34;&lt;/span>
email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;somebody@company.com&amp;#34;&lt;/span>
},
&lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> ...
]
}
&lt;span style="color:#66d9ef">resource&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pagerduty_user&amp;#34; &amp;#34;users&amp;#34;&lt;/span> {
for_each &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">local&lt;/span>.&lt;span style="color:#66d9ef">users&lt;/span>
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">each&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.&lt;span style="color:#66d9ef">name&lt;/span>
email &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">each&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.&lt;span style="color:#66d9ef">email&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But why wouldn&amp;rsquo;t it accept array? If I think about it again, it&amp;rsquo;s for a good reason. Let me explain.&lt;/p>
&lt;p>Suppose &lt;code>for_each&lt;/code> works with array, what would happen if at some point in the future, you remove one item in the middle of the array? Your resources from that removed index until the end will be shifted forward and neds to be recreated by Terraform. Don&amp;rsquo;t forget that Terraform use index for array resources. So for &lt;code>pagerduty_user&lt;/code> resource, there will be &lt;code>pagerduty_user[0]&lt;/code>, &lt;code>pagerduty_user[1]&lt;/code>, &lt;code>pagerduty_user[2]&lt;/code> and soon.&lt;/p>
&lt;p>It may be fine for resources like &lt;code>pagerduty_user&lt;/code>, but what would happen if you used on machines with your database in it? And with no backup configured. Yes that could be disaster.&lt;/p></content></item><item><title>Konfigurasi Replikasi di PostgreSQL 11</title><link>https://asasmoyo.github.io/konfigurasi-replikasi-di-postgresql-11/</link><pubDate>Sun, 21 Oct 2018 13:45:33 +0700</pubDate><author>Arba Sasmoyo</author><guid>https://asasmoyo.github.io/konfigurasi-replikasi-di-postgresql-11/</guid><description/><content>&lt;p>Yay PostgreSQL 11 baru saja keluar bulan lalu (lihat &lt;a href="https://news.ycombinator.com/item?id=18248050">di sini&lt;/a> untuk diskusi HN). Yuk kita coba mengkonfigurasi replikasi di PostgreSQL 11.&lt;/p>
&lt;h1 id="replikasi-di-postgresql">Replikasi di PostgreSQL&lt;/h1>
&lt;p>Replikasi di PostgreSQL didasarkan pada teknologi Write Ahead Log (WAL). Fungsi WAL sangat simpel. Seperti namanya, WAL menjadikan PostgreSQL untuk menulis log sebelum setiap perubahan yang terjadi. Perubahan data tidak akan dilakukan sebelum WAL berhasil disimpan ke storage. Log ini berisi perubahan yang dilakukan kepada PostgreSQL. Dengan demikian integritas data di PostgreSQL dapat terjamin. Apabila server crash sebelum perubahan data dilakukan, PostgreSQL dapat membaca WAL terakhir dan menjalankannya lagi. Selain itu, apabila kita memiliki WAL yang lengkap, kita dapat menjalankan ulang seluruh WAL dari awal sampai akhir untuk mendapatkan state terakhir. Sehingga WAL juga dapat digunakan untuk mekanisme backup juga.&lt;/p>
&lt;p>Fungsi WAL tidak hanya itu saja. Bagaimana jika kita mengirim WAL dari server PostgreSQL A ke server B, dan server B langsung menjalankan WAL ketika menerimanya. Yap, server B akan memiliki state yang sama dengan server A! Inilah yang disebut sebagai &lt;em>streaming replication&lt;/em> pada PostgreSQL.&lt;/p>
&lt;p>Memang tidak ketika perubahan terjadi di server A, server B seketika itu juga memiliki state yang sama dengan server A. Terdapat delay selama beberapa saat sebelum state server B sama dengan server A. Hal ini dikarenakan diperlukan waktu untuk mengirimkan WAL dari server A ke server B, dan server B juga memerlukan waktu untuk menjalankan WAL yang diterima. Akan tetapi kita bisa menjamin bahwa suatu saat nanti, server B akan memiliki state yang sama dengan server A. Hal ini disebut sebagai &lt;em>eventually consistent&lt;/em>.&lt;/p>
&lt;p>Akan tetapi bagaimana jika terdapat WAL yang hilang di network, sehingga server B tidak akan pernah menerimanya. Jika ini terjadi maka server B tidak akan pernah bisa memiliki state yang sama dengan server A. Untuk mengatasi hal ini, PostgreSQL memiliki fitur untuk menjalankan WAL dari sumber lain. Akan tetapi WAL yang ditulis di server A harus disimpan pada storage yang dapat diakses dari server B.&lt;/p>
&lt;h1 id="konfigurasi-replikasi">Konfigurasi replikasi&lt;/h1>
&lt;p>Kita akan menggunakan PostgreSQL versi 11 pada server Ubuntu 18.04. Replikasi yang kita buat akan memiliki skema seperti ini:&lt;/p>
&lt;p>&lt;img src="https://asasmoyo.github.io/images/2018-10/postgres-replication-diagram.png" alt="diagram">&lt;/p>
&lt;p>Kita akan membutuhkan 4 server. Diasumsikan bahwa untuk server berikut dapat melakukan passwordless SSH ke server lain (cek &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server#copying-your-public-key-manually">di sini&lt;/a> untuk bagaimana mengkonfigurasi passwordless SSH):&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">primary, slave1, slave2 -&amp;gt; wal_storage
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>primary&lt;/code> merupakan server utama yang menjalankan perubahan data dari client. Sedangkan &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code> merupakan server yang menerima WAL dari &lt;code>primary&lt;/code>. Sedangkan &lt;code>wal_storage&lt;/code> merupaan server yang menyimpan WAL yang ditulis dari server &lt;code>primary&lt;/code>, &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Install PostgreSQL 11&lt;/p>
&lt;p>Ikuti langkan &lt;a href="https://www.postgresql.org/download/linux/ubuntu/">di sini&lt;/a> untuk menginstall PostgreSQL 11 di server &lt;code>primary&lt;/code>, &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Membuat user replikasi&lt;/p>
&lt;p>Server slave harus terhubung ke server &lt;code>primary&lt;/code> untuk mendapatkan akses ke WAL server &lt;code>primary&lt;/code>. Kita akan menggunakan user khusus untuk ini. Untuk membuatnya, pada server &lt;code>primary&lt;/code>, &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code> masuk ke user &lt;code>postgres&lt;/code> lalu jalankan perintah berikut:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">psql -c &lt;span style="color:#e6db74">&amp;#34;create user replicator with replication login;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Opsi &lt;code>replication&lt;/code> menandakan bahwa user yang dibuat merupakan user khusus yang digunakan untuk replikasi dan opsi &lt;code>login&lt;/code> memungkinkan user ini untuk melakukan login dari server lain.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Konfigurasi &lt;code>pg_hba.conf&lt;/code>&lt;/p>
&lt;p>PostgreSQL memiliki file &lt;code>pg_hba.conf&lt;/code> yang befungsi untuk mengatur koneksi yang diijinkan masuk. Agar replikasi dapat berjalan, maka &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code> harus dapat mengakses &lt;code>primary&lt;/code> dengan menggunakan user &lt;code>replicator&lt;/code>. Untuk itu tambahkan baris berikut pada &lt;code>/etc/postgresql/11/main/pg_hba.conf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># ganti NETWORK dengan CIDR yang mencakup server primary, slave1 dan slave2&lt;/span>
&lt;span style="color:#75715e"># misal 10.11.12.0/24&lt;/span>
host replication replicator NETWORK trust
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Baris tersebut artinya &lt;em>koneksi yang masuk lewat TCP/IP, yang berasal dari IP yang termasuk CIDR yang didefinisikasn di &lt;code>NETWORK&lt;/code>, yang menggunakan user &lt;code>replicator&lt;/code> untuk keperluan &lt;code>replication&lt;/code>, akan diijinkan&lt;/em>.&lt;/p>
&lt;p>Lakukan ini di server &lt;code>primary&lt;/code>, &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Konfigurasi PostgreSQL&lt;/p>
&lt;p>Buka file &lt;code>/etc/postgresql/11/main/postgresql.conf&lt;/code> dan sesuaikan/tambahkan konfigurasi untuk:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">listen_addresses &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;*&amp;#39;&lt;/span>
wal_level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;replica&amp;#39;&lt;/span> &lt;span style="color:#75715e"># diperlukan agar data yang ditulis di WAL dapat digunakan untuk keperluan replikasi&lt;/span>
max_wal_senders &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#75715e"># jumlah proses pengiriman WAL yang diijinkan, paling tidak harus sama dengan jumlah server slave&lt;/span>
wal_keep_segments &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">500&lt;/span> &lt;span style="color:#75715e"># jumlah file WAL yang disimpan&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lakukan ini di server &lt;code>primary&lt;/code>, &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>. Lalu restart service postgres agar PostgreSQL membaca perubahan konfigurasi.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Konfigurasi penyimpanan WAL&lt;/p>
&lt;p>Tambahkan baris berikut di &lt;code>/etc/postgresql/11/main/postgresql.conf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">archive_mode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;on&amp;#39;&lt;/span>
archive_command &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;rsync -az %p $USER@$IP_WAL_STORAGE:~/wals/&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kita menggunakan &lt;code>archive_command&lt;/code> untuk menyimpan file WAL yang dibuat oleh PostgreSQL di server &lt;code>wal_storage&lt;/code>. &lt;code>archive_command&lt;/code> akan dijalankan untuk setiap file WAL yang dibuat oleh PostgreSQL. Kita menggunakan &lt;code>rsync&lt;/code> untuk menyimpan file WAL. Kenapa &lt;code>rsync&lt;/code>? Karena kita memiliki 3 server PostgreSQL yang menghasilkan WAL yang sama maka kita harus mengecek apakah file WAL telah disimpan ke storage. Dengan menggunakan &lt;code>rsync&lt;/code>, kita bisa menghilangkan proses pengecekan tersebut. Karena &lt;code>rsync&lt;/code> tidak akan melakukan apa apa apabila file WAL telah disimpan.&lt;/p>
&lt;p>Lakukan ini di server &lt;code>primary&lt;/code>, &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>. Lalu restart service postgres agar PostgreSQL membaca perubahan konfigurasi.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Copy state &lt;code>primary&lt;/code> ke slave&lt;/p>
&lt;p>Jalankan perintah berikut di server &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">systemctl stop postgresql
rm -rf /var/lib/postgresql/11/main
pg_basebackup --pgdata&lt;span style="color:#f92672">=&lt;/span>/var/lib/postgresql/11/main --write-recovery-conf --progress --verbose --host&lt;span style="color:#f92672">=&lt;/span>$IP_PRIMARY --username&lt;span style="color:#f92672">=&lt;/span>replicator
chown -R postgres:postgres /var/lib/postgresql/11/main
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Perintah di atas akan membuat ulang data PostgreSQL agar memiliki state yang sama dengan &lt;code>primary&lt;/code>. Selain itu juga mengkonfigurasi &lt;em>streaming replication&lt;/em> pada file &lt;code>/var/lib/postgresql/11/main/recovery.conf&lt;/code> yang berisi:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">standby_mode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;on&amp;#39;&lt;/span>
primary_conninfo &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;user=replicator passfile=&amp;#39;&amp;#39;/root/.pgpass&amp;#39;&amp;#39; host=IP_PRIMARY port=5432 sslmode=prefer sslcompression=0 krbsrvname=postgres target_session_attrs=any&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tambahkan baris berikut pada &lt;code>/var/lib/postgresql/11/main/recovery.conf&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">restore_command &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;rsync -az $USER@$IP_WAL_STORAGE:~/wals/%f %p&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dengan konfigurasi &lt;code>recovery.conf&lt;/code> seperti di atas, server akan terus menjalankan WAL yang didapat dari server &lt;code>primary&lt;/code>. Selain itu, apabila file WAL tidak didapatkan dari &lt;em>streaming replication&lt;/em>, server akan menjalankan perintah yang terdapat pada &lt;code>restore_command&lt;/code> untuk mendapatkan file WAL tersebut.&lt;/p>
&lt;p>Selanjutnya jalankan service postgres pada server &lt;code>slave1&lt;/code> dan &lt;code>slave2&lt;/code>. Jika konfigurasi benar, akan muncul proses &lt;code>postgres: 11/main: walsender&lt;/code> pada server &lt;code>primary&lt;/code> untuk setiap slave yang terhubung.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#ae81ff">17659&lt;/span> ? Ss 0:00 postgres: 11/main: walsender replicator IP_SLAVE_1&lt;span style="color:#f92672">(&lt;/span>51648&lt;span style="color:#f92672">)&lt;/span> streaming 0/7000060
&lt;span style="color:#ae81ff">17660&lt;/span> ? Ss 0:00 postgres: 11/main: walsender replicator IP_SLAVE_2&lt;span style="color:#f92672">(&lt;/span>60446&lt;span style="color:#f92672">)&lt;/span> streaming 0/7000060
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h1 id="tes-replikasi">Tes replikasi&lt;/h1>
&lt;p>Semua perubahan yang terjadi pada server &lt;code>primary&lt;/code> akan diikuti oleh server slave juga. Untuk mencobanya dapat dilakukan dengan membuat database / tabel pada server &lt;code>primary&lt;/code>. Setelah beberapa saat, database / tabel tersebut juga akan muncul pada server slave.&lt;/p>
&lt;p>Selain itu, status replikasi dapat juga dilakukan dengan melakukan query berikut di server &lt;code>primary&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">postgres&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#75715e"># select * from pg_stat_replication;&lt;/span>
-&lt;span style="color:#f92672">[&lt;/span> RECORD &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">]&lt;/span>----+------------------------------
pid | &lt;span style="color:#ae81ff">17659&lt;/span>
usesysid | &lt;span style="color:#ae81ff">16384&lt;/span>
usename | replicator
application_name | walreceiver
client_addr | IP_SLAVE_1
client_hostname |
client_port | &lt;span style="color:#ae81ff">51648&lt;/span>
backend_start | 2018-11-15 16:48:02.177309+00
backend_xmin |
state | streaming
sent_lsn | 0/7000140
write_lsn | 0/7000140
flush_lsn | 0/7000140
replay_lsn | 0/7000140
write_lag |
flush_lag |
replay_lag |
sync_priority | &lt;span style="color:#ae81ff">0&lt;/span>
sync_state | async
-&lt;span style="color:#f92672">[&lt;/span> RECORD &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">]&lt;/span>----+------------------------------
pid | &lt;span style="color:#ae81ff">17660&lt;/span>
usesysid | &lt;span style="color:#ae81ff">16384&lt;/span>
usename | replicator
application_name | walreceiver
client_addr | IP_SLAVE_2
client_hostname |
client_port | &lt;span style="color:#ae81ff">60446&lt;/span>
backend_start | 2018-11-15 16:48:05.640884+00
backend_xmin |
state | streaming
sent_lsn | 0/7000140
write_lsn | 0/7000140
flush_lsn | 0/7000140
replay_lsn | 0/7000140
write_lag |
flush_lag |
replay_lag |
sync_priority | &lt;span style="color:#ae81ff">0&lt;/span>
sync_state | async
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>Demikianlah fitur replikasi bawaan PostgreSQL. Apabila diperhatikan, replikasi hanya berjalan satu arah. Perubahan dari server &lt;code>primary&lt;/code> akan direplikasi ke server slave, akan tetapi tidak sebaliknya. Oleh karena itu semua query yang melakukan perubahan ke database harus diarahkan ke server &lt;code>primary&lt;/code> dan kapasitas perubahan database dibatasi oleh spesifikasi server &lt;code>primary&lt;/code>. Akan tetapi, query yang membaca data dari database dapat ditujukan ke salah satu server slave. Apabila kebutuhan kapasitas perubahan database sangat besar dan sebuah server &lt;code>primary&lt;/code> tidak dapat mengatasinya, maka skenario ini tidak dapat digunakan. Terdapat beberapa project lain yang memungkinkan menggunakan skenario multi-master pada PostgreSQL, misalnya &lt;a href="https://www.cockroachlabs.com">Cockroachdb&lt;/a> dan &lt;a href="https://www.citusdata.com/">Citus&lt;/a>.&lt;/p></content></item><item><title>Running Ethereum Private Network</title><link>https://asasmoyo.github.io/running-ethereum-private-network/</link><pubDate>Tue, 31 Oct 2017 12:38:12 +0700</pubDate><author>Arba Sasmoyo</author><guid>https://asasmoyo.github.io/running-ethereum-private-network/</guid><description/><content>&lt;p>One good way to understand Ethereum is by creating your own Ethereum private network. I have been trying to understand Ethereum in the past few weeks and I learned a lot of things just by creating it. I&amp;rsquo;ll now write down what I got from creating Ethereum private network. And I&amp;rsquo;ll update this post as I learn new things&amp;hellip; hopefully&lt;/p>
&lt;p>First of all, Ethereum client works by connecting to a network specified by its &lt;code>networkid&lt;/code>. The normal network where people usually connecting to is public network with &lt;code>networkid=1&lt;/code> (you can see it &lt;a href="https://github.com/ethereum/go-ethereum/blob/b0ca1b67ce6e297fe02281d01a486225bbf385f8/eth/config.go#L42">here&lt;/a>). But it is not the only network you can connect to, you can also create your own Ethereum network.&lt;/p>
&lt;p>Typical Ethereum network consists of:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Bootnode&lt;/p>
&lt;p>You might be wondering how an Ethereum node can connect to other nodes and broadcast messages. It turns out they have special nodes called bootnode. Basically, they works as node discovery where you can join and ask for other nodes addresses that you can connect to.&lt;/p>
&lt;p>You can see the default bootnodes value &lt;a href="https://github.com/ethereum/go-ethereum/blob/b0ca1b67ce6e297fe02281d01a486225bbf385f8/params/bootnodes.go#L21">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Normal node&lt;/p>
&lt;p>They are just normal node people usually run.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Miner&lt;/p>
&lt;p>They are strong miners who make money out of thin air.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Actually you can run a node as normal node and miner at the same time. But in this post I&amp;rsquo;m going to run them separately so we can understand better what they are doing.&lt;/p>
&lt;h2 id="requirements">Requirements&lt;/h2>
&lt;p>I&amp;rsquo;ll use Golang version of Ethereum clients. I haven&amp;rsquo;t tried other client implementations but they should also work, maybe&amp;hellip;&lt;/p>
&lt;p>You can download pre-built binary here: &lt;a href="https://geth.ethereum.org/downloads/">https://geth.ethereum.org/downloads/&lt;/a>, please download the latest one with name: &lt;code>Geth &amp;amp; Tools&lt;/code>. Unlike &lt;code>Geth&lt;/code>, it contains &lt;code>geth&lt;/code> and &lt;code>bootnode&lt;/code> binaries needed for this post.&lt;/p>
&lt;p>Please download and add the binaries to your &lt;code>PATH&lt;/code>, in this post I assume all of those binary are already included in &lt;code>PATH&lt;/code>.&lt;/p>
&lt;h2 id="create-accounts">Create accounts&lt;/h2>
&lt;p>Ethereum doesn&amp;rsquo;t need you to register in order to join the network. What you need to do is just create an account which consists of a private key and a public key, with a password for security, then you can just use the address. If you use &lt;code>geth&lt;/code> to generate an account, both private and public key will be hidden in a weird looking &lt;code>json&lt;/code> file.&lt;/p>
&lt;p>Creating account in Ethereum is simple, let&amp;rsquo;s use &lt;code>geth&lt;/code> to create one:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">geth --datadir&lt;span style="color:#f92672">=&lt;/span>accounts account new
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will then asked to type password. The created account information will be saved in &lt;code>accounts/keystore/UTC--{year}-{month}--{account}&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Make sure to &lt;strong>SAVE THE PASSWORD SECURELY&lt;/strong>, because there is no way to retrieve your password once you lost it&lt;/p>
&lt;/blockquote>
&lt;p>Example account:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;address&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;07eafaabd1e6dce571f1931092fc1586b55f896e&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;crypto&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;cipher&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;aes-128-ctr&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;ciphertext&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;b5f65c754374915d7c02a156d7d4328dcb612a4ac6287fee5dd90dd6a074b808&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;cipherparams&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;iv&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0ae623176cdfda61136f576244cd91df&amp;#34;&lt;/span>
},
&lt;span style="color:#f92672">&amp;#34;kdf&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scrypt&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;kdfparams&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;dklen&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">32&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;n&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">262144&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;p&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;r&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">8&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;salt&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ca4847545a4a0fa9a75dd2c98c83ddd9cce18578b8b8153d0c81ef49195fb690&amp;#34;&lt;/span>
},
&lt;span style="color:#f92672">&amp;#34;mac&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;398c2fe085315d8b497d09d88866e35f6b2d038023c86f4c346ff86dbd841d17&amp;#34;&lt;/span>
},
&lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;b0272829-d924-48d4-97fb-1ec3329f3d80&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The important part is &lt;code>address&lt;/code>, as its name implies it is the address of the account. To understand better what&amp;rsquo;s stored in there you can read &lt;a href="https://ethereum.stackexchange.com/a/15606">this&lt;/a>.&lt;/p>
&lt;h2 id="create-genesis-block">Create genesis block&lt;/h2>
&lt;p>If you are not familiar with blockchain, basically blockchain consists of many blocks and each block has the hash of previous block in it. But wait, what about the very first block in the blockchain? Which block should it refers to?&lt;/p>
&lt;p>The first block in a blockchain is a special block, called genesis block. Unlike other blocks, it doesn&amp;rsquo;t need the hash of the previous block (well, there is no block before it). It sets the hash of the previous block with &lt;code>0&lt;/code>. It also can give some balance to some addresses.&lt;/p>
&lt;blockquote>
&lt;p>You can see Ethereum genesis block here: &lt;a href="https://etherscan.io/block/0">https://etherscan.io/block/0&lt;/a>. Notice it has &lt;code>Parent Hash=0&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;p>Genesis block in Ethereum is just an &lt;code>json&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;config&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;chainId&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">9999&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;homesteadBlock&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;eip155Block&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;eip158Block&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
},
&lt;span style="color:#f92672">&amp;#34;alloc&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;07eafaabd1e6dce571f1931092fc1586b55f896e&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;balance&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;100&amp;#34;&lt;/span>
}
},
&lt;span style="color:#f92672">&amp;#34;difficulty&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;100000&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;gasLimit&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;999999&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Short explanation about above genesis file:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>config.chainId&lt;/code> I am not really sure about this. But it is used for preventing replay attack accross Ethereum networks. I also see most private network examples set this to the &lt;code>networkid&lt;/code> of the private network. We will use 9999 as our &lt;code>networkid&lt;/code> in this post.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>config.homesteadBlock&lt;/code>, &lt;code>eip155Block&lt;/code> and &lt;code>eip158Block&lt;/code> do not really matter in a private network&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>alloc&lt;/code> specifies initial balance for some addresses&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>difficulty&lt;/code> specifies how difficult mining should be&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Create file &lt;code>genesis.json&lt;/code> containing above json snippet (please change the address in the &lt;code>alloc&lt;/code> to be your own account address). We&amp;rsquo;ll back to this later when we are creating nodes.&lt;/p>
&lt;h2 id="setup-bootnode">Setup bootnode&lt;/h2>
&lt;p>As I said before, bootnode works as a node discovery. Nodes would need bootnode to join and discover other nodes in the network so they can do whatever they want, e.g: syncing blockchain, create transaction, mining etc.&lt;/p>
&lt;p>Setting up a bootnode is easy. First you need to create a nodekey. Essentially nodekey is an address where the bootnode run.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">bootnode --genkey&lt;span style="color:#f92672">=&lt;/span>boot.key
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>You should save your bootnode&amp;rsquo;s nodekey. If the value is changed, you will have to update your other nodes to point to the new bootnode&amp;rsquo;s address.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Technically, nodekey is not the real address of the bootnode. Nodekey is just a public key and it needs to be hashed first to get the real address. See &lt;a href="https://ethereum.stackexchange.com/questions/3542/how-are-ethereum-addresses-generated">this&lt;/a> for further explanation.&lt;/p>
&lt;/blockquote>
&lt;p>It will create a nodekey and save it to &lt;code>boot.key&lt;/code>.&lt;/p>
&lt;p>You will also need the real address of bootnode so other nodes can use it as their bootnode. You can get it by:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">bootnode --nodekey&lt;span style="color:#f92672">=&lt;/span>boot.key --writeaddress
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="setup-nodes">Setup nodes&lt;/h2>
&lt;p>Now we need to setup Ethereum nodes. Since we are going to use our own private network we will need to initialize our nodes with our genesis block.&lt;/p>
&lt;blockquote>
&lt;p>You have to do this for all nodes in our private network&lt;/p>
&lt;/blockquote>
&lt;p>You can initalize a node by:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">geth --datadir&lt;span style="color:#f92672">=&lt;/span>nodeX init genesis.json
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please replace &lt;code>nodeX&lt;/code> with a path where the node will save its data. Let&amp;rsquo;s create a node and a miner, so run the above command with &lt;code>--datadir=node&lt;/code> and &lt;code>--datadir=miner&lt;/code>. It will initialize the nodes using our own genesis block definition in &lt;code>genesis.json&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>We don&amp;rsquo;t need to specify genesis block when initalizing nodes in main network. Because genesis block for the main network is already hard coded in &lt;code>geth&lt;/code>, see &lt;a href="https://github.com/ethereum/go-ethereum/blob/6d6a5a93370371a33fb815d7ae47b60c7021c86a/core/genesis.go#L310">here&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>We need to initialize all of our nodes with our genesis block because if they use the default genesis block they will not be able to sync to our private network&amp;rsquo;s blocks.&lt;/p>
&lt;/blockquote>
&lt;h2 id="running-all-together">Running all together&lt;/h2>
&lt;p>Let&amp;rsquo;s put everything together. First we run the bootnode:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">bootnode --nodekey&lt;span style="color:#f92672">=&lt;/span>boot.key --verbosity&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">9&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I added &lt;code>--verbosity=9&lt;/code> so we can easily see if the bootnode is working and other nodes are able to connect to bootnode. If it runs ok it should output something like:&lt;/p>
&lt;pre>&lt;code>INFO [10-31|21:26:21] UDP listener up self=enode://157e68e800266d39015a125f3c20a499cd190940e2a665854e0fb80f62f7c00734acc6eb277c06f0b5cb5840436b0ab3980761e7c58a27bfa052c10560db2bc7@[::]:30301
&lt;/code>&lt;/pre>&lt;p>&lt;code>enode://...&lt;/code> is the bootnode&amp;rsquo;s address and &lt;code>@[::]:30301&lt;/code> means that it runs on all interfaces at port 30301.&lt;/p>
&lt;p>Next we run the node. We can run it by:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">geth --networkid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">9999&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --port&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">9001&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --bootnodes&lt;span style="color:#f92672">=&lt;/span>enode://157e68e800266d39015a125f3c20a499cd190940e2a665854e0fb80f62f7c00734acc6eb277c06f0b5cb5840436b0ab3980761e7c58a27bfa052c10560db2bc7@127.0.0.1:30301 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --datadir&lt;span style="color:#f92672">=&lt;/span>node
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please make sure to adjust the bootnode address from bootnode&amp;rsquo;s logs. I added &lt;code>--port=9001&lt;/code> so that we can run multiple nodes in a host, they will run on different ports. If it runs ok the bootnode will output something like:&lt;/p>
&lt;pre>&lt;code>TRACE[10-31|21:40:08] &amp;gt;&amp;gt; PONG/v4 addr=127.0.0.1:9001 err=nil
TRACE[10-31|21:40:08] &amp;lt;&amp;lt; PING/v4 addr=127.0.0.1:9001 err=nil
TRACE[10-31|21:40:08] Starting bonding ping/pong id=4b2c152d338bdff6 known=false failcount=0 age=419294h40m8.013456s
TRACE[10-31|21:40:08] &amp;gt;&amp;gt; PING/v4 addr=127.0.0.1:9001 err=nil
TRACE[10-31|21:40:08] &amp;lt;&amp;lt; PONG/v4 addr=127.0.0.1:9001 err=nil
TRACE[10-31|21:40:08] &amp;gt;&amp;gt; NEIGHBORS/v4 addr=127.0.0.1:9001 err=nil
TRACE[10-31|21:40:08] &amp;lt;&amp;lt; FINDNODE/v4 addr=127.0.0.1:9001 err=nil
&lt;/code>&lt;/pre>&lt;p>Last, let&amp;rsquo;s run the miner node:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">geth --networkid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">9999&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --port&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">9002&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --bootnodes&lt;span style="color:#f92672">=&lt;/span>enode://157e68e800266d39015a125f3c20a499cd190940e2a665854e0fb80f62f7c00734acc6eb277c06f0b5cb5840436b0ab3980761e7c58a27bfa052c10560db2bc7@127.0.0.1:30301 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --datadir&lt;span style="color:#f92672">=&lt;/span>miner &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --mine &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --minerthreads&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --etherbase&lt;span style="color:#f92672">=&lt;/span>07eafaabd1e6dce571f1931092fc1586b55f896e
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>--miner&lt;/code> makes the node to start mining after it is ready, &lt;code>--minerthreads&lt;/code> sets how many threads will be used for mining and &lt;code>--etherbase&lt;/code> will store the reward of mining to the specified address. If it runs ok it should have output like:&lt;/p>
&lt;pre>&lt;code>INFO [10-31|21:48:48] Starting mining operation
INFO [10-31|21:48:48] Commit new mining work number=1 txs=0 uncles=0 elapsed=164.218Âµs
INFO [10-31|21:48:49] Successfully sealed new block number=1 hash=d13118â€¦8fadfb
INFO [10-31|21:48:49] ðŸ”¨ mined potential block number=1 hash=d13118â€¦8fadfb
INFO [10-31|21:48:49] Commit new mining work number=2 txs=0 uncles=0 elapsed=115.035Âµs
INFO [10-31|21:48:57] Successfully sealed new block number=2 hash=8c7c30â€¦f6871b
INFO [10-31|21:48:57] ðŸ”¨ mined potential block number=2 hash=8c7c30â€¦f6871b
INFO [10-31|21:48:57] Commit new mining work number=3 txs=0 uncles=0 elapsed=194.539Âµs
INFO [10-31|21:48:59] Successfully sealed new block number=3 hash=f688baâ€¦303090
&lt;/code>&lt;/pre>&lt;p>Notice the node&amp;rsquo;s logs, you should see something like this whenever the miner successfully mine a new block:&lt;/p>
&lt;pre>&lt;code>INFO [10-31|21:46:45] Imported new chain segment blocks=2 txs=0 mgas=0.000 elapsed=1.234ms mgasps=0.000 number=2 hash=c9b5eaâ€¦2c638c
INFO [10-31|21:46:45] Fast sync complete, auto disabling
INFO [10-31|21:46:48] Imported new chain segment blocks=1 txs=0 mgas=0.000 elapsed=4.415ms mgasps=0.000 number=3 hash=b53689â€¦b40d46
INFO [10-31|21:47:14] Imported new chain segment blocks=1 txs=0 mgas=0.000 elapsed=3.285ms mgasps=0.000 number=4 hash=e69fd2â€¦5cabe7
&lt;/code>&lt;/pre>&lt;p>It shows us that the node just updated its blockchain. Remember, miner can find other nodes via bootnode. So whenever miner successfully mine a new block, it can ask some nodes addresses from bootnode then broadcast the new block to them.&lt;/p>
&lt;p>Great! Our private network is now working well. We can see our current balance using console:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">geth attach node/geth.ipc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can check balance of the address used for mining:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; eth.getBalance&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;07eafaabd1e6dce571f1931092fc1586b55f896e&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#ae81ff">245000000000000000100&lt;/span> &lt;span style="color:#75715e"># this one is in &amp;#39;wei&amp;#39; unit, see http://ethdocs.org/en/latest/ether.html#denominations. Of couse we can convert it to &amp;#39;ether&amp;#39; unit&lt;/span>
&amp;gt; web3.fromWei&lt;span style="color:#f92672">(&lt;/span>eth.getBalance&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;07eafaabd1e6dce571f1931092fc1586b55f896e&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;ether&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
290.0000000000000001 &lt;span style="color:#75715e"># ez money=ez life :p&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Check this to learn about what you can do in the console: &lt;a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">https://github.com/ethereum/wiki/wiki/JavaScript-API&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Okay that&amp;rsquo;s all for this post. I hope now you understand, at least, how to setup your own Ethereum private network. I&amp;rsquo;ll cover more topics later about creating more secure private network and transfering ether&amp;hellip; probably&lt;/p></content></item><item><title>Setup PostgreSQL on Ubuntu 16.04</title><link>https://asasmoyo.github.io/setup-postgresql/</link><pubDate>Tue, 14 Mar 2017 21:33:58 +0700</pubDate><author>Arba Sasmoyo</author><guid>https://asasmoyo.github.io/setup-postgresql/</guid><description/><content>&lt;h3 id="install-postgresql">Install PostgreSQL&lt;/h3>
&lt;p>By default, Ubuntu 16.04 instance has already &lt;code>postgresql&lt;/code> package, but it is pretty out of date. You can still install latest version available (currently 9.6) by adding PostgreSQL repo into your ubuntu instance.&lt;/p>
&lt;p>First create a file at &lt;code>/etc/apt/sources.list.d/postgres.list&lt;/code> with this content&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then run these commands to install PostgreSQL signing key and also install PostgreSQL 9.6&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
sudo apt-get update
sudo apt-get install postgresql-9.6
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now PostgreSQL should already running on your machine. To check it you can use&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo systemctl status postgresql
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="create-user-and-database">Create User and Database&lt;/h3>
&lt;p>Newly created PostgreSQL instance has a superuser called &lt;code>postgres&lt;/code> without a password. Fortunately &lt;code>postgres&lt;/code> user can only login from &lt;code>localhost&lt;/code> so it should be secure by default. If you want to add password to &lt;code>postgres&lt;/code> you can run&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo su postgres -c psql
&lt;span style="color:#75715e"># after in PostgreSQL cli&lt;/span>
&lt;span style="color:#ae81ff">\p&lt;/span>assword
&lt;/code>&lt;/pre>&lt;/div>&lt;p>It is better to have it&amp;rsquo;s own user and database for each applications. To create them you can use&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># create user first&lt;/span>
create user &lt;span style="color:#e6db74">&amp;#34;user_name&amp;#34;&lt;/span> with password &lt;span style="color:#e6db74">&amp;#39;please_change_me&amp;#39;&lt;/span> login;
&lt;span style="color:#75715e"># then create database&lt;/span>
create database &lt;span style="color:#e6db74">&amp;#34;db_name&amp;#34;&lt;/span> owner &lt;span style="color:#e6db74">&amp;#39;user_name&amp;#39;&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="allow-remote-connections">Allow Remote Connections&lt;/h3>
&lt;p>The PostgreSQL instance that have been installed will listen to &lt;code>localhost&lt;/code> and only allow &lt;code>postgres&lt;/code> user to connect inside the machine without password authentication. To enable remote connections, there are 2 things that need to be done.&lt;/p>
&lt;p>First you must change PostgreSQL listen address to your machine ip, for example your machine private ip. Open &lt;code>/etc/postgresql/9.6/main/postgresql.conf&lt;/code> and find this line&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#listen=&amp;#39;localhost&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Change it into&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">listen&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;your_private_ip&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then you also need to allow remote connections to access your PostgreSQL instance. To do that open &lt;code>/etc/postgresql/9.6/main/pg_hba.conf&lt;/code> and add this line to the end of the file&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">host db_name user_name 0.0.0.0/0 md5
&lt;/code>&lt;/pre>&lt;/div>&lt;p>It will allows remote connections from anywhere (notice &lt;code>0.0.0.0/0&lt;/code>) to access &lt;code>db_name&lt;/code> with user &lt;code>user_name&lt;/code>. You can improve the security by changing &lt;code>0.0.0.0/0&lt;/code> to specific address, like &lt;code>192.168.1.20/32&lt;/code>. Restart the PostgreSQL instance by &lt;code>sudo systemctl restart postgresql&lt;/code> then your remote clients should be able to connect to your PostgreSQL instance.&lt;/p></content></item></channel></rss>