<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Konfigurasi Replikasi di PostgreSQL 11 | relax, you're probably doing fine</title><link href=https://asasmoyo.github.io/index.xml rel=alternate type=application/rss+xml title="relax, you're probably doing fine"><link rel=stylesheet href=/css/style.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://asasmoyo.github.io/blog/konfigurasi-replikasi-di-postgresql-11/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><section class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://asasmoyo.github.io><h1 id=nav-heading class="title is-4">relax, you're probably doing fine</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=email href=mailto:arba.sasmoyo@gmail.com target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></i></span></a><a class=level-item aria-label=github href=https://github.com/asasmoyo target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></i></span></a><a class=level-item aria-label=linkedin href=https://linkedin.com/in/asasmoyo target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path stroke-width="1.8" d="m5.839218 4.101561c0 1.211972-.974141 2.194011-2.176459 2.194011S1.4863 5.313533 1.4863 4.101561c0-1.211094.974141-2.194011 2.176459-2.194011s2.176459.982917 2.176459 2.194011zm.017552 3.94922h-4.388022v14.04167H5.85677V8.050781zm7.005038.0H8.501869v14.04167h4.360816v-7.370999c0-4.098413 5.291077-4.433657 5.291077.0v7.370999h4.377491v-8.89101c0-6.915523-7.829986-6.66365-9.669445-3.259423V8.050781z"/></svg></i></span></a></nav></div></nav><nav class=nav></nav></div><script src=/js/navicon-shift.js></script></section><section class=section><div class=container><div class="subtitle tags is-6 is-pulled-right"></div><h2 class="subtitle is-6">October 21, 2018</h2><h1 class=title>Konfigurasi Replikasi di PostgreSQL 11</h1><div class=content><p>Yay PostgreSQL 11 baru saja keluar bulan lalu (lihat <a href="https://news.ycombinator.com/item?id=18248050">di sini</a> untuk diskusi HN). Yuk kita coba mengkonfigurasi replikasi di PostgreSQL 11.</p><h1 id=replikasi-di-postgresql>Replikasi di PostgreSQL</h1><p>Replikasi di PostgreSQL didasarkan pada teknologi Write Ahead Log (WAL). Fungsi WAL sangat simpel. Seperti namanya, WAL menjadikan PostgreSQL untuk menulis log sebelum setiap perubahan yang terjadi. Perubahan data tidak akan dilakukan sebelum WAL berhasil disimpan ke storage. Log ini berisi perubahan yang dilakukan kepada PostgreSQL. Dengan demikian integritas data di PostgreSQL dapat terjamin. Apabila server crash sebelum perubahan data dilakukan, PostgreSQL dapat membaca WAL terakhir dan menjalankannya lagi. Selain itu, apabila kita memiliki WAL yang lengkap, kita dapat menjalankan ulang seluruh WAL dari awal sampai akhir untuk mendapatkan state terakhir. Sehingga WAL juga dapat digunakan untuk mekanisme backup juga.</p><p>Fungsi WAL tidak hanya itu saja. Bagaimana jika kita mengirim WAL dari server PostgreSQL A ke server B, dan server B langsung menjalankan WAL ketika menerimanya. Yap, server B akan memiliki state yang sama dengan server A! Inilah yang disebut sebagai <em>streaming replication</em> pada PostgreSQL.</p><p>Memang tidak ketika perubahan terjadi di server A, server B seketika itu juga memiliki state yang sama dengan server A. Terdapat delay selama beberapa saat sebelum state server B sama dengan server A. Hal ini dikarenakan diperlukan waktu untuk mengirimkan WAL dari server A ke server B, dan server B juga memerlukan waktu untuk menjalankan WAL yang diterima. Akan tetapi kita bisa menjamin bahwa suatu saat nanti, server B akan memiliki state yang sama dengan server A. Hal ini disebut sebagai <em>eventually consistent</em>.</p><p>Akan tetapi bagaimana jika terdapat WAL yang hilang di network, sehingga server B tidak akan pernah menerimanya. Jika ini terjadi maka server B tidak akan pernah bisa memiliki state yang sama dengan server A. Untuk mengatasi hal ini, PostgreSQL memiliki fitur untuk menjalankan WAL dari sumber lain. Akan tetapi WAL yang ditulis di server A harus disimpan pada storage yang dapat diakses dari server B.</p><h1 id=konfigurasi-replikasi>Konfigurasi replikasi</h1><p>Kita akan menggunakan PostgreSQL versi 11 pada server Ubuntu 18.04. Replikasi yang kita buat akan memiliki skema seperti ini:</p><p><img src=/images/2018-10/postgres-replication-diagram.png alt=diagram></p><p>Kita akan membutuhkan 4 server. Diasumsikan bahwa untuk server berikut dapat melakukan passwordless SSH ke server lain (cek <a href=https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server#copying-your-public-key-manually>di sini</a> untuk bagaimana mengkonfigurasi passwordless SSH):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>primary, slave1, slave2 -&gt; wal_storage
</code></pre></div><p><code>primary</code> merupakan server utama yang menjalankan perubahan data dari client. Sedangkan <code>slave1</code> dan <code>slave2</code> merupakan server yang menerima WAL dari <code>primary</code>. Sedangkan <code>wal_storage</code> merupaan server yang menyimpan WAL yang ditulis dari server <code>primary</code>, <code>slave1</code> dan <code>slave2</code>.</p><ol><li><p>Install PostgreSQL 11</p><p>Ikuti langkan <a href=https://www.postgresql.org/download/linux/ubuntu/>di sini</a> untuk menginstall PostgreSQL 11 di server <code>primary</code>, <code>slave1</code> dan <code>slave2</code>.</p></li><li><p>Membuat user replikasi</p><p>Server slave harus terhubung ke server <code>primary</code> untuk mendapatkan akses ke WAL server <code>primary</code>. Kita akan menggunakan user khusus untuk ini. Untuk membuatnya, pada server <code>primary</code>, <code>slave1</code> dan <code>slave2</code> masuk ke user <code>postgres</code> lalu jalankan perintah berikut:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>psql -c <span style=color:#e6db74>&#34;create user replicator with replication login;&#34;</span>
</code></pre></div><p>Opsi <code>replication</code> menandakan bahwa user yang dibuat merupakan user khusus yang digunakan untuk replikasi dan opsi <code>login</code> memungkinkan user ini untuk melakukan login dari server lain.</p></li><li><p>Konfigurasi <code>pg_hba.conf</code></p><p>PostgreSQL memiliki file <code>pg_hba.conf</code> yang befungsi untuk mengatur koneksi yang diijinkan masuk. Agar replikasi dapat berjalan, maka <code>slave1</code> dan <code>slave2</code> harus dapat mengakses <code>primary</code> dengan menggunakan user <code>replicator</code>. Untuk itu tambahkan baris berikut pada <code>/etc/postgresql/11/main/pg_hba.conf</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># ganti NETWORK dengan CIDR yang mencakup server primary, slave1 dan slave2</span>
<span style=color:#75715e># misal 10.11.12.0/24</span>
host replication replicator NETWORK trust
</code></pre></div><p>Baris tersebut artinya <em>koneksi yang masuk lewat TCP/IP, yang berasal dari IP yang termasuk CIDR yang didefinisikasn di <code>NETWORK</code>, yang menggunakan user <code>replicator</code> untuk keperluan <code>replication</code>, akan diijinkan</em>.</p><p>Lakukan ini di server <code>primary</code>, <code>slave1</code> dan <code>slave2</code>.</p></li><li><p>Konfigurasi PostgreSQL</p><p>Buka file <code>/etc/postgresql/11/main/postgresql.conf</code> dan sesuaikan/tambahkan konfigurasi untuk:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>listen_addresses <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;*&#39;</span>
wal_level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;replica&#39;</span> <span style=color:#75715e># diperlukan agar data yang ditulis di WAL dapat digunakan untuk keperluan replikasi</span>
max_wal_senders <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> <span style=color:#75715e># jumlah proses pengiriman WAL yang diijinkan, paling tidak harus sama dengan jumlah server slave</span>
wal_keep_segments <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span> <span style=color:#75715e># jumlah file WAL yang disimpan</span>
</code></pre></div><p>Lakukan ini di server <code>primary</code>, <code>slave1</code> dan <code>slave2</code>. Lalu restart service postgres agar PostgreSQL membaca perubahan konfigurasi.</p></li><li><p>Konfigurasi penyimpanan WAL</p><p>Tambahkan baris berikut di <code>/etc/postgresql/11/main/postgresql.conf</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>archive_mode <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;on&#39;</span>
archive_command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;rsync -az %p $USER@$IP_WAL_STORAGE:~/wals/&#39;</span>
</code></pre></div><p>Kita menggunakan <code>archive_command</code> untuk menyimpan file WAL yang dibuat oleh PostgreSQL di server <code>wal_storage</code>. <code>archive_command</code> akan dijalankan untuk setiap file WAL yang dibuat oleh PostgreSQL. Kita menggunakan <code>rsync</code> untuk menyimpan file WAL. Kenapa <code>rsync</code>? Karena kita memiliki 3 server PostgreSQL yang menghasilkan WAL yang sama maka kita harus mengecek apakah file WAL telah disimpan ke storage. Dengan menggunakan <code>rsync</code>, kita bisa menghilangkan proses pengecekan tersebut. Karena <code>rsync</code> tidak akan melakukan apa apa apabila file WAL telah disimpan.</p><p>Lakukan ini di server <code>primary</code>, <code>slave1</code> dan <code>slave2</code>. Lalu restart service postgres agar PostgreSQL membaca perubahan konfigurasi.</p></li><li><p>Copy state <code>primary</code> ke slave</p><p>Jalankan perintah berikut di server <code>slave1</code> dan <code>slave2</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl stop postgresql
rm -rf /var/lib/postgresql/11/main
pg_basebackup --pgdata<span style=color:#f92672>=</span>/var/lib/postgresql/11/main --write-recovery-conf --progress --verbose --host<span style=color:#f92672>=</span>$IP_PRIMARY --username<span style=color:#f92672>=</span>replicator
chown -R postgres:postgres /var/lib/postgresql/11/main
</code></pre></div><p>Perintah di atas akan membuat ulang data PostgreSQL agar memiliki state yang sama dengan <code>primary</code>. Selain itu juga mengkonfigurasi <em>streaming replication</em> pada file <code>/var/lib/postgresql/11/main/recovery.conf</code> yang berisi:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>standby_mode <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;on&#39;</span>
primary_conninfo <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;user=replicator passfile=&#39;&#39;/root/.pgpass&#39;&#39; host=IP_PRIMARY port=5432 sslmode=prefer sslcompression=0 krbsrvname=postgres target_session_attrs=any&#39;</span>
</code></pre></div><p>Tambahkan baris berikut pada <code>/var/lib/postgresql/11/main/recovery.conf</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>restore_command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;rsync -az $USER@$IP_WAL_STORAGE:~/wals/%f %p&#39;</span>
</code></pre></div><p>Dengan konfigurasi <code>recovery.conf</code> seperti di atas, server akan terus menjalankan WAL yang didapat dari server <code>primary</code>. Selain itu, apabila file WAL tidak didapatkan dari <em>streaming replication</em>, server akan menjalankan perintah yang terdapat pada <code>restore_command</code> untuk mendapatkan file WAL tersebut.</p><p>Selanjutnya jalankan service postgres pada server <code>slave1</code> dan <code>slave2</code>. Jika konfigurasi benar, akan muncul proses <code>postgres: 11/main: walsender</code> pada server <code>primary</code> untuk setiap slave yang terhubung.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>17659</span> ?        Ss     0:00 postgres: 11/main: walsender replicator IP_SLAVE_1<span style=color:#f92672>(</span>51648<span style=color:#f92672>)</span> streaming 0/7000060
<span style=color:#ae81ff>17660</span> ?        Ss     0:00 postgres: 11/main: walsender replicator IP_SLAVE_2<span style=color:#f92672>(</span>60446<span style=color:#f92672>)</span> streaming 0/7000060
</code></pre></div></li></ol><h1 id=tes-replikasi>Tes replikasi</h1><p>Semua perubahan yang terjadi pada server <code>primary</code> akan diikuti oleh server slave juga. Untuk mencobanya dapat dilakukan dengan membuat database / tabel pada server <code>primary</code>. Setelah beberapa saat, database / tabel tersebut juga akan muncul pada server slave.</p><p>Selain itu, status replikasi dapat juga dilakukan dengan melakukan query berikut di server <code>primary</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>postgres<span style=color:#f92672>=</span><span style=color:#75715e># select * from pg_stat_replication;</span>
-<span style=color:#f92672>[</span> RECORD <span style=color:#ae81ff>1</span> <span style=color:#f92672>]</span>----+------------------------------
pid              | <span style=color:#ae81ff>17659</span>
usesysid         | <span style=color:#ae81ff>16384</span>
usename          | replicator
application_name | walreceiver
client_addr      | IP_SLAVE_1
client_hostname  |
client_port      | <span style=color:#ae81ff>51648</span>
backend_start    | 2018-11-15 16:48:02.177309+00
backend_xmin     |
state            | streaming
sent_lsn         | 0/7000140
write_lsn        | 0/7000140
flush_lsn        | 0/7000140
replay_lsn       | 0/7000140
write_lag        |
flush_lag        |
replay_lag       |
sync_priority    | <span style=color:#ae81ff>0</span>
sync_state       | async
-<span style=color:#f92672>[</span> RECORD <span style=color:#ae81ff>2</span> <span style=color:#f92672>]</span>----+------------------------------
pid              | <span style=color:#ae81ff>17660</span>
usesysid         | <span style=color:#ae81ff>16384</span>
usename          | replicator
application_name | walreceiver
client_addr      | IP_SLAVE_2
client_hostname  |
client_port      | <span style=color:#ae81ff>60446</span>
backend_start    | 2018-11-15 16:48:05.640884+00
backend_xmin     |
state            | streaming
sent_lsn         | 0/7000140
write_lsn        | 0/7000140
flush_lsn        | 0/7000140
replay_lsn       | 0/7000140
write_lag        |
flush_lag        |
replay_lag       |
sync_priority    | <span style=color:#ae81ff>0</span>
sync_state       | async
</code></pre></div><hr><p>Demikianlah fitur replikasi bawaan PostgreSQL. Apabila diperhatikan, replikasi hanya berjalan satu arah. Perubahan dari server <code>primary</code> akan direplikasi ke server slave, akan tetapi tidak sebaliknya. Oleh karena itu semua query yang melakukan perubahan ke database harus diarahkan ke server <code>primary</code> dan kapasitas perubahan database dibatasi oleh spesifikasi server <code>primary</code>. Akan tetapi, query yang membaca data dari database dapat ditujukan ke salah satu server slave. Apabila kebutuhan kapasitas perubahan database sangat besar dan sebuah server <code>primary</code> tidak dapat mengatasinya, maka skenario ini tidak dapat digunakan. Terdapat beberapa project lain yang memungkinkan menggunakan skenario multi-master pada PostgreSQL, misalnya <a href=https://www.cockroachlabs.com>Cockroachdb</a> dan <a href=https://www.citusdata.com/>Citus</a>.</p><div class=related></div></div></div></section><section class=section><div class=container><aside><div id=disqus_thread></div></aside><div id=show_comments><a id=load_comments class="button is-link">Load comments</a></div><script type=text/javascript>var disqus_shortname='asasmoyo-github-io';function disqus(){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);}
var hash=window.location.hash.substr(1);if((hash.length>8)&&(hash.substring(0,8)==="comment-")){disqus();document.getElementById("show_comments").style.display="none";}else{document.getElementById('load_comments').onclick=function(){disqus();document.getElementById("show_comments").style.display="none";};}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-109033209-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>